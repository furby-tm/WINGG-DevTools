#line 1 "C:/Users/tyler/dev/WINGG/forge/imaging/hdPh/resourceBinder.h"
/*
 * Copyright 2021 Forge. All Rights Reserved.
 *
 * The use of this software is subject to the terms of the
 * Forge license agreement provided at the time of installation
 * or download, or which otherwise accompanies this software in
 * either electronic or hard copy form.
 *
 * Portions of this file are derived from original work by Pixar
 * distributed with Universal Scene Description, a project of the
 * Academy Software Foundation (ASWF). https://www.aswf.io/
 *
 * Original Copyright (C) 2016-2021 Pixar.
 * Modifications copyright (C) 2020-2021 ForgeXYZ LLC.
 *
 * Forge. The Animation Software & Motion Picture Co.
 */
#ifndef FORGE_IMAGING_HD_PH_RESOURCE_BINDER_H
#define FORGE_IMAGING_HD_PH_RESOURCE_BINDER_H

#include "forge/forge.h"
#include "forge/imaging/hd/version.h"
#include "forge/imaging/hdPh/api.h"

#include "forge/base/tf/staticTokens.h"
#include "forge/base/tf/stl.h"
#include "forge/base/tf/token.h"
#include "forge/imaging/hd/binding.h"
#include "forge/imaging/hgi/shaderProgram.h"

#include <memory>

FORGE_NAMESPACE_BEGIN

class HdPhDrawItem;

using HdPhBufferResourceSharedPtr = std::shared_ptr<class HdPhBufferResource>;
using HdPhBufferArrayRangeSharedPtr = std::shared_ptr<class HdPhBufferArrayRange>;

using HdPhShaderCodeSharedPtr = std::shared_ptr<class HdPhShaderCode>;
using HdPhShaderCodeSharedPtrVector = std::vector<HdPhShaderCodeSharedPtr>;
using HdBindingRequestVector = std::vector<class HdBindingRequest>;

/// Suffixes appended to material param names for a binding name.
///
#define HDPH_RESOURCE_BINDING_SUFFIX_TOKENS \
  ((fallback, "_fallback"))((samplingTransform, "_samplingTransform"))((layout, "_layout"))( \
      (texture, "_texture"))((valid, "_valid"))

#ifndef DOXYGEN_SHOULD_SKIP_THIS
TF_DECLARE_PUBLIC_TOKENS(HdPh_ResourceBindingSuffixTokens, HDPH_RESOURCE_BINDING_SUFFIX_TOKENS);
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

/// \class HdPh_ResourceBinder
///
/// A helper class to maintain all vertex/buffer/uniform binding points to be
/// used for both codegen time and rendering time.
///
/// Phoenix uses 6 different types of coherent buffers.
///
/// 1. Constant buffer
///   constant primvars, which is uniform for all instances/elements/vertices.
///     ex. transform, object color
//    [SSBO, BindlessUniform]
///
/// 2. Instance buffer
///   instance primvars, one-per-instance.
///     ex. translate/scale/rotate, instanceIndices
//    [SSBO, BindlessUniform]
///
/// 3. Element buffer
///   element primvars. one-per-element (face, line).
///     ex. face color
///   [SSBO]
///
/// 4. Vertex buffer
///   vertex primvars. one-per-vertex.
///     ex. positions, normals, vertex color
///   [VertexAttribute]
///
/// 5. Index buffer
///   points/triangles/quads/lines/patches indices.
///     ex. indices, primitive param.
///   [IndexAttribute, SSBO]
///
/// 6. DrawIndex buffer
///   draw command data. one-per-drawitem (gl_DrawID equivalent)
///     ex. drawing coordinate, instance counts
///   [VertexAttribute]
///
///
///
/// For instance index indirection, three bindings are needed:
///
///    +-----------------------------------------+
///    |  instance indices buffer resource       | <-- <arrayBinding>
///    +-----------------------------------------+
///    |* culled instance indices buffer resource| <-- <culledArrayBinding>
///    +-----------------------------------------+  (bindless uniform
///                  ^   ^      ^                      or SSBO)
/// DrawCalls +---+  |   |      |
///          0|   |---   |      |
///           +---+      |      |
///          1|   |-------      |
///           +---+             |
///          2|   |--------------
///           +---+
///             ^
///             --- <baseBinding>
///                  (immediate:uniform, indirect:vertex attrib)
///
/// (*) GPU frustum culling shader shuffles instance indices into
///     culled indices buffer.
///
///
/// HdPh_ResourceBinder also takes custom bindings.
///
/// Custom bindings are used to manage bindable resources for
/// glsl shader code which is not itself generated by codegen.
///
/// For each custom binding, codegen will emit a binding definition
/// that can be used as the value of a glsl \a binding or
/// \a location layout qualifier.
///
/// e.g. Adding a custom binding of 2 for "paramsBuffer", will
/// cause codegen to emit the definition:
/// \code
/// #define paramsBuffer_Binding 2
/// \endcode
/// which can be used in a custom glsl resource declaration as:
/// \code
/// layout (binding = paramsBuffer_Binding) buffer ParamsBuffer { ... };
/// \endcode
///
class HdPh_ResourceBinder {
 public:
  /// binding metadata for codegen
  class MetaData {
   public:
    MetaData() : instancerNumLevels(0)
    {
    }

    typedef size_t ID;
    /// Returns the hash value of this metadata.
    HDPH_API
    ID ComputeHash() const;

    // -------------------------------------------------------------------
    // for a primvar in interleaved buffer array (Constant, ShaderData)
    struct StructEntry {
      StructEntry(TfToken const &name, TfToken const &dataType, int offset, int arraySize)
          : name(name), dataType(dataType), offset(offset), arraySize(arraySize)
      {
      }

      TfToken name;
      TfToken dataType;
      int offset;
      int arraySize;

      bool operator<(StructEntry const &other) const
      {
        return offset < other.offset;
      }
    };
    struct StructBlock {
      StructBlock(TfToken const &name) : blockName(name)
      {
      }
      TfToken blockName;
      std::vector<StructEntry> entries;
    };
    typedef std::map<HdBinding, StructBlock> StructBlockBinding;

    // -------------------------------------------------------------------
    // for a primvar in non-interleaved buffer array (Vertex, Element, ...)
    struct Primvar {
      Primvar()
      {
      }
      Primvar(TfToken const &name, TfToken const &dataType) : name(name), dataType(dataType)
      {
      }
      TfToken name;
      TfToken dataType;
    };
    typedef std::map<HdBinding, Primvar> PrimvarBinding;

    // -------------------------------------------------------------------
    // for instance primvars
    struct NestedPrimvar {
      NestedPrimvar()
      {
      }
      NestedPrimvar(TfToken const &name, TfToken const &dataType, int level)
          : name(name), dataType(dataType), level(level)
      {
      }
      TfToken name;
      TfToken dataType;
      int level;
    };
    typedef std::map<HdBinding, NestedPrimvar> NestedPrimvarBinding;

    // -------------------------------------------------------------------
    // for shader parameter accessors
    struct ShaderParameterAccessor {
      ShaderParameterAccessor()
      {
      }
      ShaderParameterAccessor(TfToken const &name,
                              TfToken const &dataType,
                              std::string const &swizzle = std::string(),
                              TfTokenVector const &inPrimvars = TfTokenVector(),
                              bool const isPremultiplied = false,
                              bool const processTextureFallbackValue = false)
          : name(name),
            dataType(dataType),
            swizzle(swizzle),
            inPrimvars(inPrimvars),
            isPremultiplied(isPremultiplied),
            processTextureFallbackValue(processTextureFallbackValue)
      {
      }
      TfToken name;                      // e.g. Kd
      TfToken dataType;                  // e.g. vec4
      std::string swizzle;               // e.g. xyzw
      TfTokenVector inPrimvars;          // for primvar renaming and texture
                                         // coordinates,
      bool isPremultiplied;              // indicates if texture parameter has been
                                         // pre-multiplied by alpha on the CPU
      bool processTextureFallbackValue;  // use NAME_fallback from shader
                                         // bar if texture is not valid
                                         // (determineed from bool
                                         // NAME_valid or bindless
                                         // handle), only supported for
                                         // material shader and for uv
                                         // and field textures.
    };
    typedef std::map<HdBinding, ShaderParameterAccessor> ShaderParameterBinding;

    // -------------------------------------------------------------------
    // for specific buffer array (drawing coordinate, instance indices)
    struct BindingDeclaration {
      BindingDeclaration()
      {
      }
      BindingDeclaration(TfToken const &name, TfToken const &dataType, HdBinding binding)
          : name(name), dataType(dataType), binding(binding)
      {
      }
      TfToken name;
      TfToken dataType;
      HdBinding binding;
    };

    // -------------------------------------------------------------------

    StructBlockBinding constantData;
    StructBlockBinding shaderData;
    StructBlockBinding topologyVisibilityData;
    PrimvarBinding elementData;
    PrimvarBinding vertexData;
    PrimvarBinding varyingData;
    PrimvarBinding fvarData;
    PrimvarBinding computeReadWriteData;
    PrimvarBinding computeReadOnlyData;
    NestedPrimvarBinding instanceData;
    int instancerNumLevels;

    ShaderParameterBinding shaderParameterBinding;

    BindingDeclaration drawingCoord0Binding;
    BindingDeclaration drawingCoord1Binding;
    BindingDeclaration drawingCoord2Binding;
    BindingDeclaration drawingCoordIBinding;
    BindingDeclaration instanceIndexArrayBinding;
    BindingDeclaration culledInstanceIndexArrayBinding;
    BindingDeclaration instanceIndexBaseBinding;
    BindingDeclaration primitiveParamBinding;
    BindingDeclaration edgeIndexBinding;

    StructBlockBinding customInterleavedBindings;
    std::vector<BindingDeclaration> customBindings;
  };

  /// Constructor.
  HDPH_API
  HdPh_ResourceBinder();

  /// Assign all binding points used in drawitem and custom bindings.
  /// Returns metadata to be used for codegen.
  HDPH_API
  void ResolveBindings(HdPhDrawItem const *drawItem,
                       HdPhShaderCodeSharedPtrVector const &shaders,
                       MetaData *metaDataOut,
                       bool indirect,
                       bool instanceDraw,
                       HdBindingRequestVector const &customBindings);

  /// Assign all binding points used in computation.
  /// Returns metadata to be used for codegen.
  HDPH_API
  void ResolveComputeBindings(HdBufferSpecVector const &readWriteBufferSpecs,
                              HdBufferSpecVector const &readOnlyBufferSpecs,
                              HdPhShaderCodeSharedPtrVector const &shaders,
                              MetaData *metaDataOut);

  /// call GL introspection APIs and fix up binding locations,
  /// in case if explicit resource location qualifier is not available
  /// (GL 4.2 or before)
  HDPH_API
  void IntrospectBindings(HgiShaderProgramHandle const &hgiProgram);

  HDPH_API
  void Bind(HdBindingRequest const &req) const;
  HDPH_API
  void Unbind(HdBindingRequest const &req) const;

  /// bind/unbind BufferArray
  HDPH_API
  void BindBufferArray(HdPhBufferArrayRangeSharedPtr const &bar) const;
  HDPH_API
  void UnbindBufferArray(HdPhBufferArrayRangeSharedPtr const &bar) const;

  /// bind/unbind interleaved constant buffer
  HDPH_API
  void BindConstantBuffer(HdPhBufferArrayRangeSharedPtr const &constantBar) const;
  HDPH_API
  void UnbindConstantBuffer(HdPhBufferArrayRangeSharedPtr const &constantBar) const;

  /// bind/unbind interleaved buffer
  HDPH_API
  void BindInterleavedBuffer(HdPhBufferArrayRangeSharedPtr const &constantBar,
                             TfToken const &name) const;
  HDPH_API
  void UnbindInterleavedBuffer(HdPhBufferArrayRangeSharedPtr const &constantBar,
                               TfToken const &name) const;

  /// bind/unbind nested instance BufferArray
  HDPH_API
  void BindInstanceBufferArray(HdPhBufferArrayRangeSharedPtr const &bar, int level) const;
  HDPH_API
  void UnbindInstanceBufferArray(HdPhBufferArrayRangeSharedPtr const &bar, int level) const;

  /// bind/unbind shader parameters and textures
  HDPH_API
  void BindShaderResources(HdPhShaderCode const *shader) const;
  HDPH_API
  void UnbindShaderResources(HdPhShaderCode const *shader) const;

  /// piecewise buffer binding utility
  /// (to be used for frustum culling, draw indirect result)
  HDPH_API
  void BindBuffer(TfToken const &name, HdPhBufferResourceSharedPtr const &resource) const;
  HDPH_API
  void BindBuffer(TfToken const &name,
                  HdPhBufferResourceSharedPtr const &resource,
                  int offset,
                  int level = -1) const;
  HDPH_API
  void UnbindBuffer(TfToken const &name,
                    HdPhBufferResourceSharedPtr const &resource,
                    int level = -1) const;

  /// bind(update) a standalone uniform (unsigned int)
  HDPH_API
  void BindUniformui(TfToken const &name, int count, const unsigned int *value) const;

  /// bind a standalone uniform (signed int, ivec2, ivec3, ivec4)
  HDPH_API
  void BindUniformi(TfToken const &name, int count, const int *value) const;

  /// bind a standalone uniform array (int[N])
  HDPH_API
  void BindUniformArrayi(TfToken const &name, int count, const int *value) const;

  /// bind a standalone uniform (float, vec2, vec3, vec4, mat4)
  HDPH_API
  void BindUniformf(TfToken const &name, int count, const float *value) const;

  /// Returns whether a binding exists.
  bool HasBinding(TfToken const &name, int level = -1) const
  {
    return _bindingMap.find(NameAndLevel(name, level)) != _bindingMap.end();
  }

  /// Returns binding point.
  /// XXX: exposed temporarily for drawIndirectResult
  /// see Hd_IndirectDrawBatch::_BeginGPUCountVisibleInstances()
  HdBinding GetBinding(TfToken const &name, int level = -1) const
  {
    HdBinding binding;
    TfMapLookup(_bindingMap, NameAndLevel(name, level), &binding);
    return binding;
  }

  int GetNumReservedUniformBlockLocations() const
  {
    return _numReservedUniformBlockLocations;
  }

  int GetNumReservedTextureUnits() const
  {
    return _numReservedTextureUnits;
  }

 private:
  // for batch execution
  struct NameAndLevel {
    NameAndLevel(TfToken const &n, int lv = -1) : name(n), level(lv)
    {
    }
    TfToken name;
    int level;

    bool operator<(NameAndLevel const &other) const
    {
      return name < other.name || (name == other.name && level < other.level);
    }
  };
  typedef std::map<NameAndLevel, HdBinding> _BindingMap;
  _BindingMap _bindingMap;
  int _numReservedUniformBlockLocations;
  int _numReservedTextureUnits;
};

FORGE_NAMESPACE_END

#endif  // FORGE_IMAGING_HD_PH_RESOURCE_BINDER_H
